"use client";

import { useEffect, useState } from "react";
import Link from "next/link";
import { useRouter, useSearchParams } from "next/navigation";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Slider } from "@/components/ui/slider";
import { Switch } from "@/components/ui/switch";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { BookOpen, LogOut, Wand2, Eye, Download } from "lucide-react";
import { Badge } from "@/components/ui/badge";

import { jsPDF } from "jspdf";

export default function TestGenerationPage() {
  const router = useRouter();
  const searchParams = useSearchParams();

  const [selectedBank, setSelectedBank] = useState("");
  const [testName, setTestName] = useState("");
  const [testVersions, setTestVersions] = useState(3);
  const [selectedCategories, setSelectedCategories] = useState<string[]>([]);
  const [questionTypes, setQuestionTypes] = useState({
    multipleChoice: false,
    trueFalse: false,
    shortAnswer: true,
  });
  const [questionCounts, setQuestionCounts] = useState({
    multipleChoice: 0,
    trueFalse: 0,
    shortAnswer: 0,
  });
  const [previewGenerated, setPreviewGenerated] = useState(false);
  const [groupedQuestions, setGroupedQuestions] = useState<{ [key: string]: any[] }>({});
  const [selectedQuestions, setSelectedQuestions] = useState<any[]>([]);

  // Fetch question banks from the API and group by subject_course
  useEffect(() => {
    const fetchQuestionBanks = async () => {
      try {
        const response = await fetch("/api/questions");
        if (!response.ok) {
          throw new Error("Failed to fetch question banks");
        }
        const data = await response.json();

        // Group questions by subject_course
        const grouped = data.questions.reduce((acc: { [key: string]: any[] }, question: any) => {
          const course = question.subject_course || "Unknown Course";
          if (!acc[course]) {
            acc[course] = [];
          }
          acc[course].push(question);
          return acc;
        }, {});
        setGroupedQuestions(grouped); // Update state with grouped questions
      } catch (error) {
        console.error("Error fetching question banks:", error);
      }
    };

    fetchQuestionBanks();
  }, []);

  const handleCategoryToggle = (category: string) => {
    if (selectedCategories.includes(category)) {
      setSelectedCategories(selectedCategories.filter((c) => c !== category));
    } else {
      setSelectedCategories([...selectedCategories, category]);
    }
  };

  const handleGeneratePreview = () => {
    setPreviewGenerated(true);
  };

  const generateMarkdown = () => {
    if (selectedQuestions.length === 0) {
      alert("No questions selected!");
      return;
    }

    const markdownContent = `
# Test: ${testName || "Untitled Test"}

#### Number of Versions: ${testVersions}

---

## Questions:

${selectedQuestions
        .map(
          (question, index) => `
### Question ${index + 1}

**Question Text:** ${question.question_text}
`
        )
        .join("\n")}

---

Proudly generated by accelGrading
`;

    return markdownContent;
  };

  const downloadPDF = () => {
    if (selectedQuestions.length === 0) {
      alert("No questions selected!");
      return;
    }

    const doc = new jsPDF();

    // Add title
    doc.setFontSize(16);
    doc.text(`Test: ${testName || "Untitled Test"}`, 10, 10);

    // Add questions
    doc.setFontSize(12);
    const questionsText = selectedQuestions
      .map(
        (question, index) =>
          `Question ${index + 1}:\nCategory: ${question.category || "General"}\n${question.question_text}\n\n`
      )
      .join("\n");
    doc.text(questionsText, 10, 20);

    // Save the PDF
    doc.save(`${testName || "test"}.pdf`);
  };

  const downloadMarkdown = (markdown: string) => {
    const blob = new Blob([markdown], { type: "text/markdown;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = `${testName || "test"}.md`;
    link.click();
    URL.revokeObjectURL(url);
  };

  const totalQuestions = Object.entries(questionTypes)
    .filter(([_, enabled]) => enabled)
    .reduce((sum, [type]) => sum + questionCounts[type as keyof typeof questionCounts], 0);

  return (
    <div className="min-h-screen flex flex-col">
      <header className="border-b">
        <div className="container flex items-center justify-between py-4">
          <div className="flex items-center gap-2">
            <Link href="/dashboard" className="flex items-center gap-2">
              <BookOpen className="h-6 w-6 text-primary" />
              <span className="text-xl font-bold">accelGrading</span>
            </Link>
          </div>

          <div className="flex items-center gap-4">
            <Button variant="ghost" size="icon" onClick={() => router.push("/")}>
              <LogOut className="h-5 w-5" />
              <span className="sr-only">Log out</span>
            </Button>
          </div>
        </div>
      </header>

      <main className="flex-1 container py-8">
        <div className="flex flex-col md:flex-row md:items-center justify-between mb-8 gap-4">
          <div>
            <h1 className="text-3xl font-bold">Test Generation</h1>
            <p className="text-muted-foreground">Create multiple versions of tests with AI</p>
          </div>
        </div>

        <div className="grid md:grid-cols-3 gap-8">
          <div className="md:col-span-2">
            <Card>
              <CardHeader>
                <CardTitle>Test Configuration</CardTitle>
                <CardDescription>Configure your test parameters to generate multiple versions</CardDescription>
              </CardHeader>
              <CardContent className="space-y-6">
                <div className="space-y-2">
                  <Label htmlFor="test-name">Test Name</Label>
                  <Input
                    id="test-name"
                    placeholder="Midterm Exam 1"
                    value={testName}
                    onChange={(e) => setTestName(e.target.value)}
                  />
                </div>

                <div className="space-y-2">
                  <Label htmlFor="question-bank">Question Bank</Label>
                  <Select
                    value={selectedBank}
                    onValueChange={(value) => setSelectedBank(value)}
                  >
                    <SelectTrigger id="question-bank">
                      <SelectValue placeholder="Select a question bank" />
                    </SelectTrigger>
                    <SelectContent>
                      {Object.keys(groupedQuestions).length > 0 ? (
                        Object.keys(groupedQuestions).map((key) => (
                          <SelectItem key={key} value={key}>
                            {key}
                          </SelectItem>
                        ))
                      ) : (
                        <p className="text-sm text-muted-foreground">Loading...</p>
                      )}
                    </SelectContent>
                  </Select>
                </div>

                <div className="space-y-4">
                  <Label>Questions</Label>
                  {selectedBank && groupedQuestions[selectedBank] ? (
                    groupedQuestions[selectedBank].map((question) => (
                      <div key={question.id} className="flex items-center gap-4">
                        <input
                          type="checkbox"
                          checked={selectedQuestions.some((q) => q.id === question.id)}
                          onChange={(e) => {
                            if (e.target.checked) {
                              setSelectedQuestions((prev) => [...prev, question]);
                            } else {
                              setSelectedQuestions((prev) =>
                                prev.filter((q) => q.id !== question.id)
                              );
                            }
                          }}
                        />
                        <div>
                          <p className="font-medium">{question.question_text}</p>
                          <p className="text-sm text-muted-foreground">{question.category}</p>
                        </div>
                      </div>
                    ))
                  ) : (
                    <p className="text-sm text-muted-foreground">No questions available</p>
                  )}
                </div>

                <Button
                  className="w-full"
                  onClick={generateMarkdown}
                  disabled={selectedQuestions.length === 0 || !testName}
                >
                  <Download className="h-4 w-4 mr-2" />
                  Download Markdown
                </Button>
                <Button
                  className="w-full"
                  onClick={downloadPDF}
                  disabled={selectedQuestions.length === 0 || !testName}
                >
                  <Download className="h-4 w-4 mr-2" />
                  Download PDF
                </Button>
              </CardContent>
            </Card>
          </div>
        </div>
      </main>

      <footer className="border-t py-4">
        <div className="container flex justify-between items-center">
          <div className="text-sm text-muted-foreground">Â© {new Date().getFullYear()} accelGrading</div>
          <div className="flex gap-4">
            <Button variant="ghost" size="sm" onClick={() => router.push("/dashboard")}>
              Dashboard
            </Button>
          </div>
        </div>
      </footer>
    </div>
  );
}
